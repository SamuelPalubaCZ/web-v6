---
description:
globs:
alwaysApply: true
---

Next.js and Modern Web Development Best Practices Rulebook

Development Philosophy and Planning
	•	Clean, Maintainable Code: Emphasize writing clear and scalable code. Follow principles like SOLID, DRY (Don’t Repeat Yourself), and KISS (Keep It Simple, Stupid) to make the codebase easier to understand and extend. Favor functional programming and composition over complex inheritance hierarchies.
	•	Type Safety and Static Analysis: Use TypeScript to catch errors at compile time and improve developer tooling. Rely on static analysis (linters, type checkers) to enforce code quality. Remember that TypeScript’s type checks don’t run at runtime – use runtime validation for critical inputs.
	•	Step-by-Step Planning: Before coding, break down features into smaller tasks. Write detailed pseudocode or diagrams for component structure and data flow. Consider edge cases and error scenarios in advance. This upfront planning helps avoid architectural mistakes and ensures you cover all requirements.
	•	Component-Driven Development: Build your UI using reusable React components. Start with small building blocks and compose them into larger features. This makes the app modular and easier to test. Each component should have a single responsibility, and complex logic should be moved into helper functions or custom hooks.

Code Style and Formatting
	•	Indentation and Semicolons: Use consistent indentation (tabs or 2/4 spaces as per project standard) for better readability. Follow a consistent rule for semicolons – many modern projects omit semicolons except where required (e.g., after IIFEs) to simplify syntax. Whichever style you choose, stick to it across the codebase.
	•	Quotations and Spacing: Use single quotes for strings in JavaScript/TypeScript, unless escaping would make double quotes clearer. Put a space after language keywords (if, for, etc.) and after commas, and around operators (= , ===, +, etc.) for readability. For example: if (isValid) { value = x + y }.
	•	Braces and Line Breaks: Use curly braces for multi-line blocks, even if they are optional. Keep else on the same line as the preceding brace (} else {). Aim for lines shorter than ~80 characters for better readability in editors. Use trailing commas in multiline object and array literals to minimize diffs.
	•	Early Returns: Favor early returns in functions to handle error conditions or special cases. This reduces deep nesting and makes the code easier to follow. For example, instead of wrapping most of a function’s logic inside if (!error) { ... }, handle the error first and return, then write the main logic without extra indentation.
	•	Comments and Documentation: Write self-documenting code with clear naming (see below), but also include comments for complex logic or important rationale. Use JSDoc/TSDoc comments on public functions, components, and data models to describe their purpose and usage. This helps other developers (and your future self) understand the code.

Naming Conventions
	•	PascalCase for Components and Types: Name React components and Typescript interfaces/types using PascalCase (e.g., UserProfileCard, AuthResponse interface). This clearly distinguishes components in JSX and types in code.
	•	camelCase for Variables and Functions: Use camelCase for variables, functions, object keys, and instances (e.g., isLoading, fetchData). Prefix boolean flags with verbs like is/has/can (e.g., hasError, canSubmit) to make their meaning obvious. Prefix event handler functions with handle (e.g., handleClick, handleFormSubmit) to signal their role.
	•	kebab-case for Files and Folders: Name files and directories using kebab-case (dash-separated lowercase). For example, a component file might be user-profile-card.tsx in a folder components/profile/. This naming scheme is URL-friendly and aligns with many Next.js file conventions.
	•	Constants and Enums: Use UPPER_SNAKE_CASE for constants and environment variables (e.g., API_BASE_URL). If using TypeScript enum (sparingly), treat them as constants in naming. Often, literal union types or constant objects are preferable to enums for flexibility.
	•	Custom Hooks and Contexts: Prefix custom React hooks with use (e.g., useAuth, useCartState) to follow convention and let linter rules validate them. Context providers and consumers should be named after their purpose (e.g., AuthProvider with useAuth hook).

React Component Best Practices
	•	Functional Components with Hooks: Use functional components for all React components. Avoid class components. Leverage React hooks to manage state and side effects. For reusable logic, create custom hooks (e.g., a useForm hook for form state management) so components remain focused on presentation.
	•	Component Composition: Build complex UI by composing smaller components. Pass data and callbacks via props rather than using global variables. This makes each component more reusable and easier to test. For example, a Modal component might accept content and actions as props, rather than assuming global state.
	•	Side Effects and Cleanup: Manage side effects with useEffect in client components. Always include cleanup functions for effects that subscribe to outside sources (event listeners, timers, subscriptions) to avoid memory leaks. Keep effects focused – if a component does multiple unrelated things in effects, consider splitting into separate components or hooks.
	•	Optimization with Memoization: Use React.memo for components that render the same props frequently to avoid unnecessary re-renders. Similarly, use useCallback or useMemo for expensive computations or to stabilize function identities across renders. This can prevent performance issues, but only apply it when needed – avoid premature optimization that complicates code.
	•	Keys in Lists: When rendering lists of elements, always provide a stable key prop for each item. The key should be unique and derived from the data (like an ID) rather than the array index, to help React preserve element state correctly across re-renders. This prevents bugs where component state is mis-assigned due to key collisions.
	•	Avoid Inline Complexity: Keep JSX markup clean. Avoid defining large functions or objects inline within the JSX return – this can hurt readability and performance. Instead, define helper functions or constants outside the component or in the component body (above the return). This prevents unnecessary re-creations on each render and makes the JSX more declarative.

Next.js Best Practices (App Router)
	•	Server Components by Default: In Next.js App Router (Next 13+), components are React Server Components by default, meaning they run on the server and their rendered HTML is sent to the client. Use this to your advantage for better performance – fetch data on the server and keep large dependencies out of the client bundle. Only mark a component as a Client Component ('use client' at the top) if it needs interactivity (state, event handlers, browser APIs) ￼. This reduces the amount of JavaScript sent to users and improves load times.
	•	Data Fetching Strategies: Choose the appropriate rendering strategy for each page or feature:
	•	Use Static Site Generation (SSG) for pages that can be pre-rendered at build time (marketing pages, blogs). Next.js will generate HTML once and reuse it, resulting in very fast page loads.
	•	Use Server-Side Rendering (SSR) for pages that need to be up-to-date on each request (e.g., dynamic content that changes often or per request). This can be done via getServerSideProps (Pages Router) or using Async Server Components (App Router) that fetch data.
	•	Use Incremental Static Regeneration (ISR) for a mix of both – static generation with periodic revalidation to update content. In App Router, this is achieved with the revalidate option on fetch or by exporting a dynamicParams/revalidate configuration.
	•	Client-Side Data Fetching: For highly interactive pages (or parts of a page) where data updates frequently on the client (like a live dashboard), use client-side data fetching with React Query or SWR. This allows realtime updates and caching on the client. However, even in these cases, try to SSR the initial page shell for better SEO and faster first paint.
	•	Next.js Routing and Architecture: Take advantage of Next.js routing conventions. Use the App Router’s file-system based routing to organize pages and nested layouts. Utilize Layout components (e.g., app/(admin)/layout.tsx) for sections of your app that share state or UI (like navbars). Use Head or metadata files to set <head> tags for pages. For error handling, implement error.tsx and not-found.tsx pages in App Router to gracefully handle exceptions and 404s.
	•	Built-in Optimizations: Leverage Next.js built-in components and features:
	•	Use the Next.js <Image> component for images. It automatically optimizes images with resizing, modern formats (WebP/AVIF), and lazy loading for better performance ￼. This prevents layout shifts and reduces bandwidth by serving appropriately sized images.
	•	Use Next.js <Link> component for internal navigation. This enables client-side transitions with prefetching (by default, Next preloads linked pages in the background), resulting in faster navigation.
	•	Use <head> / Metadata API to manage page titles, descriptions, and other SEO/meta tags in a centralized way per route.
	•	Utilize Code-Splitting with dynamic imports. Next.js supports import() to load heavy components or libraries on demand (for example, import a rich text editor component only when needed on the client). Mark non-essential or purely client-side modules with { ssr: false } if using next/dynamic to prevent them from impacting server render.
	•	URL State Management: Keep the URL in sync with application state for shareability and clarity. For example, when implementing filters or pagination, reflect these in query parameters. Next.js provides hooks like useSearchParams for reading URL query strings in the App Router. For complex scenarios, consider using nuqs – a library that manages React state via URL search params in a type-safe way ￼. This ensures state is encoded in the URL (enabling bookmarking and sharing) while abstracting parsing/serialization for you.
	•	Environment Configuration: Manage environment-specific settings using Next.js environment variables. Store secrets like API keys in server-side env files (e.g., .env.local) and mark variables with NEXT_PUBLIC_ prefix only if they are safe to expose to client-side. Next.js will inline these at build time. Avoid exposing any secret or sensitive info to the browser. Use Next.js Config (next.config.js) for settings like image domains, internationalization locales, and experimental flags in one place.

UI and Styling Practices
	•	Tailwind CSS for Styling: Use Tailwind CSS (a utility-first CSS framework) to style components rapidly and consistently. Tailwind encourages a mobile-first approach — start by designing for small screens and add responsive classes (like md:px-4 lg:px-8) for larger breakpoints. This ensures the UI is responsive by default. Avoid writing large custom CSS files; instead, compose Tailwind utility classes for most design needs to keep styles consistent and maintainable.
	•	Consistent Design with Shadcn UI/Radix: Consider using component libraries like Shadcn UI (which is built on Radix UI primitives) for pre-built accessible components. Radix provides unstyled, accessibility-tested primitives (modals, dropdowns, tooltips, etc.), and Shadcn UI offers styled implementations of these. This can accelerate development while ensuring UI components follow accessibility best practices out of the box. You can customize these components to fit your design system while retaining their robust behavior.
	•	Semantic HTML: Use semantic HTML elements whenever possible instead of generic <div>s. For example, use <header>, <main>, <footer>, <section>, <nav> to define page structure, and appropriate tags like <button> for clickable elements, <form> and inputs for forms, and headings (<h1>...<h6>) for titles. Semantic HTML improves accessibility and SEO, and it works well with Tailwind (you can apply classes to any element).
	•	Responsive and Adaptive Design: Ensure the UI works on all screen sizes. Use CSS grid or flexbox along with Tailwind’s responsive utilities to create layouts that adapt. Test components on mobile, tablet, and desktop views. Also, consider using dark mode support (Tailwind can toggle themes via dark: variant classes or a CSS class) if required – ensure sufficient color contrast in both light and dark themes.
	•	Avoid Inline Styles: Do not use inline styles or style attributes for majority of styling, as they cannot be reused or overridden easily. The only exceptions might be dynamic style attributes (like dynamic canvas sizes or coordinates) or CSS-in-JS when absolutely necessary. Even for dynamic styles, prefer computing a CSS class (for example, adding a Tailwind class conditionally via a library like clsx or using Tailwind’s JIT features) rather than inline styles, to keep consistency.

Accessibility (a11y)
	•	ARIA and Roles: Make interactive components accessible by using appropriate ARIA attributes and roles when native elements don’t suffice. For example, an expandable accordion should use ARIA attributes like aria-expanded on the trigger element, and an ARIA role of button if it’s a non- element. Use landmarks (<main>, <nav>, <aside>, etc.) for screen readers to navigate the page structure.
	•	Keyboard Navigation: All interactive elements should be reachable and operable via keyboard. This means using semantic elements like <button> (which are focusable by default) or adding tabindex="0" to custom focusable elements (and handling onKeyDown for Enter/Space if they emulate a button). Ensure focus states are visible (Tailwind provides focus: variants to style focus outlines). Test by navigating with Tab/Shift+Tab and activating elements with Enter/Space.
	•	Alt Text and Labels: Provide descriptive alt text for images, especially if they convey information. For icons or decorative images, use empty alt (alt="") or aria-hidden="true" if appropriate, to avoid noise for assistive technologies. Ensure form fields have associated <label>s or aria-label attributes. If using custom form components (like a styled dropdown), give it an accessible name and role.
	•	Color and Contrast: Follow WCAG guidelines for color contrast (generally a contrast ratio of at least 4.5:1 for text). Use design tokens or Tailwind colors that meet these contrast requirements. Also, do not rely solely on color to convey meaning (e.g., an error message should have an icon or text indicating error, not just red color highlight).
	•	Accessible Feedback: When content updates or errors occur, ensure that this is announced to users who may not see visual changes. For example, use aria-live regions for form error messages or dynamic content updates. If a section of the page loads asynchronously, consider focusing a heading or issuing a polite screen reader announcement (“results loaded”) to inform the user.
	•	Testing Accessibility: Use tools like axe-core (browser extension or in testing) to automatically check for common accessibility issues. Manually test with screen readers (VoiceOver, NVDA, or JAWS) to ensure the application is usable without sight. Ensuring accessibility upfront not only helps users with disabilities but often improves overall UX.

State Management
	•	Local State First: Use React’s built-in state (useState, useReducer) and context for local and moderately shared state. Many apps do not need heavy state management libraries if state is well localized. Follow React’s recommended approach: lift state up to the closest common ancestor that needs it, but not higher. Use useReducer for complex state logic within a component to make it more predictable.
	•	Zustand or Redux for Global State: For larger applications with complex global state needs (auth info, global modals, caches, etc.), a state library can help. Zustand is a lightweight state management library that can often replace Redux with simpler patterns – it creates a global store with reactive get/set functions. If using Redux, prefer Redux Toolkit which reduces boilerplate and encourages immutable state updates and slice-based organization. Structure global state by feature (e.g., authSlice, cartSlice) rather than one massive store. Use selectors to encapsulate data access.
	•	Avoid Over-Using Global State: Be mindful to not hoist state globally unless necessary. Too much global state can make the app harder to maintain and can cause unnecessary re-renders. If only a couple of components need a piece of state, context or prop drilling might be sufficient (prop drilling can be alleviated with context or custom hooks).
	•	React Query for Server State: Treat server-fetched data differently from client UI state. Use libraries like TanStack React Query (or SWR) for data that comes from an API. React Query provides caching, deduping multiple requests, background updates, and mechanisms for refetching on interval or on focus. This helps keep the UI in sync with the server with minimal effort. For example, use useQuery to fetch list data with caching, and useMutation for submits, handling loading and error states out of the box.
	•	URL State and Routing: As mentioned, consider the URL part of your state. Use Next.js router (or utilities like useSearchParams in App Router) to sync state that should persist in the URL (such as page number, filters, selected items). The nuqs library can assist by providing a useQueryState hook that works like useState but syncs with URL query params ￼, ensuring the state is reflected in the URL and back/forward buttons work properly. This keeps your application state shareable and restoreable via URL alone.

Data Fetching and Backend Integration
	•	Type-safe APIs and Validation: Integrate with backends in a type-safe way. If using REST, define TypeScript interfaces for request and response shapes, and use Zod to validate and parse server responses. If using GraphQL, generate TypeScript types from your schema. For full-stack type safety, consider using tRPC or Next.js Route Handlers with TypeScript types, which let you call server functions directly from the client without an extra client code layer.
	•	Supabase (or External APIs): When using backend-as-a-service like Supabase, keep security in mind. Use Supabase’s client libraries on the server when dealing with admin-level operations or secrets (e.g., using service role keys only in Next.js API routes or server components, never on the client). Take advantage of Supabase’s row-level security and authentication hooks rather than implementing your own where possible. For any direct client calls (like using Supabase from a React component for real-time data), ensure rules are in place to prevent unauthorized data access.
	•	Error Handling in API Calls: Wrap API calls in try/catch blocks and handle errors gracefully. Provide user-friendly error messages or UI states – for example, if a fetch fails, show a message with an option to retry. Log detailed error information to the console (in development) or a monitoring service (in production) for debugging. Avoid simply crashing on fetch errors or swallowing errors silently.
	•	Optimistic Updates and Loading States: When using React Query or similar, utilize features like optimistic updates for snappier UI – e.g., if a user adds an item to a list, update the UI immediately and roll back if the server call fails. Always show meaningful loading states (spinners or skeletons) for data fetching components so users know content is coming. With Next.js App Router, you can also use the built-in <Suspense> boundary to handle loading states for server components, and error boundaries for error states.
	•	Caching and Revalidation: Exploit caching to reduce load on backend and improve performance. Next.js can cache SSR pages with ISR (revalidate), and React Query caches API responses with time-based stale-while-revalidate strategies. Determine which data can be cached (e.g., static content, or user-specific data that doesn’t change frequently) and set appropriate caching headers or use Next’s fetch caching options (cache: 'force-cache' for static data, or cache: 'no-store' for always dynamic).
	•	Webhooks and Background Jobs: For apps that require real-time updates or heavy background processing, integrate webhooks or background jobs. For example, with Stripe payments, set up webhook endpoints (e.g., an API Route or a serverless function) to listen to events like checkout.session.completed or subscription status changes. This allows the server to react to events and update your application state (like updating a user’s subscription status in the database) without user intervention. Ensure to verify webhook signatures or secrets to authenticate the source of these requests. Perform heavy computations or data processing in background jobs or on the server side, not in the user’s browser, to keep the app responsive.

Error Handling and Validation
	•	Input Validation with Zod: Validate user input at the boundaries of your application. On the client side, use libraries like Zod to define schemas for forms and parse user input. Zod will ensure the data meets your criteria (e.g., correct types, within length limits) and provide meaningful error messages that you can display to the user. This prevents bad data from ever being sent to the server and gives immediate feedback to users (e.g., “Password must be at least 8 characters”).
	•	Server-side Validation: Never trust client input on the server. Use the same Zod schemas (or another validation library) on your Next.js API routes or server actions to validate and sanitize data before using it (e.g., before inserting into a database). This double-checks that no malicious or malformed data slipped through. Zod helps guarantee data integrity and type safety at runtime, effectively filling the gap in TypeScript’s compile-time checking ￼.
	•	Graceful Error UI: Implement error boundaries in React to catch runtime errors in the UI tree and display a fallback UI (such as an error message and a reload button). Next.js App Router provides an error.js file for each route segment – use it to render a user-friendly error screen and offer recovery options (like a link back to safety, or a prompt to try again). This ensures that one component’s failure doesn’t blank out the entire app.
	•	Logging and Monitoring: Set up logging for errors that occur in production. This can be as simple as sending errors to the console on the server (which Vercel captures) or as sophisticated as integrating Sentry or a similar service for frontend and backend error tracking. Include context (user ID, action being performed) in error logs where possible, but be careful to omit sensitive data. Monitoring errors helps you catch issues early and debug effectively.
	•	Edge Case Handling: Think through and handle edge cases such as empty states (no data to show), slow network or offline mode, and user actions that might break assumptions (e.g., clicking a button multiple times rapidly). For empty states, provide a placeholder graphic or message (“No items found”) instead of a blank screen. For network issues, consider using navigator.onLine or catch fetch errors to inform the user (“You appear offline, some data may be outdated”). Use debouncing or disabling UI controls to prevent duplicate actions.
	•	No Crashes or Silent Failures: The app should never crash for the user. Catch exceptions at boundaries and display something rather than letting the app break entirely. Conversely, avoid silent failures that leave the user confused – always communicate an outcome, even if it’s a generic “Something went wrong.” By combining proactive validation and robust error boundaries, you can achieve a resilient app that handles failure scenarios gracefully.

Security Best Practices
	•	Output Encoding and XSS Prevention: Protect against cross-site scripting (XSS) by sanitizing or encoding any data that is rendered as HTML. Fortunately, React auto-escapes content by default when rendering variables in JSX, which mitigates a lot of XSS risk. However, be cautious when using dangerouslySetInnerHTML or working with any rich HTML content – always sanitize it (with a library like DOMPurify) before injecting. In general, ensure that all variables go through validation and appropriate escaping/sanitization before affecting the DOM, achieving what OWASP calls perfect injection resistance ￼. This means any value that comes from users or external sources is treated as untrusted and handled safely.
	•	Avoiding Common Vulnerabilities: Use parameterized queries or ORM methods to avoid SQL injection if your app interacts with a database. Do not expose sensitive data in the frontend – for example, never send secrets like API keys to the client (use server-side proxies if necessary). Protect against CSRF (Cross-Site Request Forgery) by leveraging same-site cookies or anti-CSRF tokens for state-changing requests (Next.js’s built-in APIs or libraries like NextAuth handle this for you by default). Disable or limit any dangerous browser features (e.g., avoid using localStorage for sensitive tokens – prefer httpOnly cookies that JavaScript cannot read).
	•	Secure Headers and HTTPS: If you control custom server configuration, use security headers (Content Security Policy, X-Frame-Options, Strict-Transport-Security, etc.) via a library like Helmet. On Vercel or similar hosting, ensure your site is only served over HTTPS and consider using the Next.js headers() configuration to add security headers. A strong CSP can mitigate XSS by restricting domains for scripts/images, but be careful to test it thoroughly to not break legitimate resources.
	•	Authentication and Authorization: Implement robust authentication. If using Next.js with NextAuth or a Supabase auth, prefer secure cookie-based auth tokens. Always check user permissions on the server side (for example, in API routes or server components) – never assume the client only shows authorized data. For any API endpoints that require login, verify the user identity from the JWT or session on every request. Also, use rate limiting or bot detection on public APIs if abuse is a concern.
	•	Dependency Security: Keep your dependencies updated to pull in security fixes. Run npm audit or yarn audit regularly and address high-severity issues. Remove or avoid packages that are unmaintained or known to be vulnerable. When including third-party scripts or if using next/script for external resources, ensure the source is trusted and use Subresource Integrity (SRI) if possible.
	•	Security Testing: Treat user-supplied data with skepticism. Perform security testing or use linters (like ESLint plugins for security) to catch risky code patterns. For example, avoid using eval or dynamically constructing JSX from strings. Use the OWASP Cheat Sheets and the OWASP Top 10 as a guide to review your application for common issues. Modern frameworks help, but developers must remain vigilant and handle data safely at all times.

Performance Optimization
	•	Minimize JavaScript Payload: Because Next.js applications ship JavaScript to the browser, strive to keep the bundle size lean. Use code-splitting (next/dynamic or React.lazy/Suspense) to load pages or components only when needed. Analyze your bundle using tools like @next/bundle-analyzer to find large dependencies. If a library is very heavy and only used on a couple pages (e.g., a rich text editor or map library), import it dynamically with ssr: false if it’s client-only, so it doesn’t bloat the initial server render.
	•	Optimize Rendering: Keep state local to prevent unnecessary re-renders of large component subtrees. Use React DevTools Profiler or the Next.js React profiler to identify slow components. Leverage useMemo to memoize expensive calculations and useCallback to avoid recreating functions passed to deep child components. However, avoid micro-optimizing things that don’t affect user-perceived performance – focus on big wins like network and bundle optimizations first.
	•	Images and Assets: Always optimize images. Next.js <Image> component will serve images in WebP/AVIF and correct sizes automatically ￼, so use it for all media where possible. Specify width/height (or use responsive fill layout) to prevent layout shift. Use lazy loading for offscreen images (Next does this by default). For other assets like videos or PDFs, consider if streaming or progressive loading is appropriate. Remove or defer any assets that are not critical for initial load.
	•	Caching and CDN: Take advantage of caching at multiple levels. Next.js static assets (including static pages, images, and generated JS/CSS) are typically served via a CDN when deployed on platforms like Vercel. Verify that caching headers are optimal: static assets should have long cache lifetimes (with hashes in filenames to bust cache on deploy), while dynamic data APIs might have shorter or no caching. Use SWR or React Query’s caching for client-side data to avoid refetching data that hasn’t changed.
	•	Web Vitals Monitoring: Optimize for Core Web Vitals – Largest Contentful Paint (LCP), First Input Delay (FID), Cumulative Layout Shift (CLS), etc. Strategies include server-render as much content as possible for a fast LCP, ensure any fonts used don’t block rendering (use font-display: swap or Next’s built-in font optimization), and prevent layout shifts by reserving space for images/iframes with explicit sizes or aspect ratios. Monitor your app using tools like Google Lighthouse or PageSpeed Insights to catch regressions.
	•	Avoiding Bottlenecks: Identify any expensive operations in your app and offload them. For example, heavy computations (data parsing, image manipulation) should run on the server or a Web Worker, not block the main thread in the browser. Database queries should be optimized with proper indexing and only fetch necessary data (avoid SELECT * if not needed). If you have real-time features, use efficient protocols (like WebSockets or Next.js built-in SSE/streaming) and debounce/throttle events on the client to avoid spamming the server with requests.

Monorepo and Cross-Platform Considerations
	•	Monorepo Structure: If you maintain a monorepo (e.g., using Turborepo) with multiple apps (web, mobile, server), organize code to maximize sharing but avoid tight coupling. Use a packages/ folder for shared modules (like a UI component library, a utility functions package, or a types package) that can be imported by both your Next.js app and React Native app. Keep configurations (TS configs, linters, etc.) in sync where possible for consistency.
	•	Turborepo & Build Scripts: Use Turborepo to cache builds and speed up CI. Leverage its pipeline to only rebuild what has changed. For example, changes in the shared UI library should trigger rebuilds of web and mobile apps, but a change in a server-only package shouldn’t rebuild the mobile app. Clearly define these relationships in the Turborepo config. Also, use package.json scripts or Turborepo tasks to standardize development tasks (like yarn dev to start both web and mobile concurrently with one command).
	•	Cross-Platform UI with Tamagui: If building a cross-platform app (web and React Native), consider using Tamagui or a similar RN+Web UI kit. Tamagui provides a unified styling system and component library that works on both React DOM and React Native ￼, allowing you to write UI code once for both platforms. This can drastically improve code sharing – for instance, a form or a list UI can be shared between Next.js and an Expo app. Use Tamagui’s theming and responsive props to ensure the design looks good on both mobile and desktop.
	•	Platform-Specific Files: In a cross-platform repo, use platform-specific file naming to handle differences. For example, Next.js might use .tsx files while React Native can use .native.tsx (or vice versa) for components that need to diverge (like using <ScrollView> on native vs <div> on web). The bundler will pick the appropriate file. Strive to minimize these differences, but maintain separate files when native and web implementations differ significantly.
	•	Shared Navigation with Solito: Navigation can be shared using a library like Solito (which allows using React Navigation in native and Next.js routing on web with a unified API). This way, screen components and navigation logic can be reused, and you get a consistent navigation structure. For example, a stack navigator in native corresponds to Next.js routes on web, and Solito helps translate links between them.
	•	Testing Across Platforms: Ensure your shared components and logic are tested in both environments. Write unit tests for pure logic (which run in Node and can cover both) and use component testing or snapshot testing on each platform to catch platform-specific issues (like styling differences or RN-specific errors). For React Native, tools like React Native Testing Library can simulate component rendering similar to React Testing Library on web.

Internationalization (i18n) and Localization
	•	Library and Setup: Implement internationalization using a robust library. For Next.js, next-i18next or react-i18next works well, managing translation files and locale routing. Set up your Next.js app to handle locale subpaths or domains (Next.js i18n routing) if you serve multiple locales. For React Native (Expo), use expo-localization along with i18next to share translations between web and native.
	•	Translation Files: Store user-visible text in JSON/YAML translation files, organized by locale. Use descriptive keys for messages (e.g., "login.error.invalidPassword": "Invalid password, please try again."). Ensure that text is never hard-coded in components; always use the translation function (like t('login.error.invalidPassword')). This makes it easy to add new languages or adjust wording without touching component code.
	•	Pluralization and Formatting: Make use of i18n features for pluralization, gender, and other language-specific variations. For example, use ICU message format or library support to handle plurals (“{count} items” vs “{count} item”). Use locale-aware date and number formatting – libraries or built-in Intl API can format dates, currencies, and numbers according to the user’s locale.
	•	RTL Support: If your app needs to support right-to-left languages (Arabic, Hebrew, etc.), ensure the layout can flip appropriately. Tailwind has an rtl: variant if configured, or you might dynamically add a dir="rtl" attribute on the <html> tag for those locales. Test that your UI still looks correct in RTL (e.g., padding/margin might need adjustment if you used directional classes like pl-4 which won’t flip automatically).
	•	Locale Detection and Switching: Decide how users select their locale. You can detect browser locale on first visit (Navigator language) and default to that, but always provide a way for the user to switch language (a dropdown or menu of languages). Next.js can pre-render pages for all locales or you can lazy-load translations. Ensure that changing language reloads or re-renders the content in the new language (i18next’s useTranslation hook or Next.js router locale change).
	•	Content and SEO: For multi-language sites, make sure to use the proper meta tags (<html lang="en"> etc.) and hreflang links so search engines understand your localized pages. Translate not just static text but also things like page titles, meta descriptions, and aria labels. Keep the translations updated as the default language text changes – establish a workflow for translators to be involved when text in the app is added or modified.

Testing and Quality Assurance
	•	Unit Testing: Write unit tests for critical pure functions and for React components’ logic. Use Jest as a test runner with React Testing Library (RTL) for components. Aim to test the component’s behavior (given props and user interaction, does it render the expected output or call the expected functions?) rather than testing implementation details or internal state. For example, test that clicking a “load more” button actually calls the fetch function and updates the list, rather than testing that setState was called.
	•	Integration Testing: For parts of the app that involve multiple components or a full page, use integration tests. RTL can render an entire page (with context providers, etc.) and you can simulate user flows: e.g., render the login page, fill in form fields, click submit, and assert that an error message appears or navigation happens. These tests give confidence that various pieces work together correctly. Use mock services or MSW (Mock Service Worker) to simulate API responses in tests so you can test how the UI reacts without making real network calls.
	•	End-to-End (E2E) Testing: Consider using an E2E testing tool like Cypress or Playwright to run tests in a real browser environment. E2E tests can cover the actual Next.js application running, interacting with it like a user would (navigating pages, clicking buttons, etc.). Focus E2E tests on critical user journeys (e.g., sign-up flow, purchasing an item) since they are slower to run. These tests will catch integration issues that unit tests might miss (like router integration, build config issues, etc.).
	•	Test Coverage and Best Practices: Strive for a good test coverage, especially on core business logic and critical components, but don’t chase coverage for its own sake. It’s better to have fewer high-quality tests than a large number of trivial tests. Use meaningful test names and structure (Arrange-Act-Assert pattern). Keep tests deterministic – avoid relying on timing or external data that can flake. Reset or teardown state between tests (RTL does this by default with cleanup after each test).
	•	Linting and Formatting: Treat your linter and formatter as part of testing. Configure ESLint with rules for best practices (including accessibility checks like jsx-a11y plugin, and security lint rules if available). Also use Prettier or an equivalent to enforce consistent code style. Many issues can be caught by linters before they become bugs (e.g., using an undefined variable, improper React hook usage). Run these in CI so that any violations fail the build.
	•	Continuous Integration: Set up CI/CD pipelines that run your test suite and linters on each pull request. Automate running type checks (tsc --noEmit), tests, and linting. This ensures that no code gets merged that breaks the build or introduces obvious errors. If possible, also add a step for running build (to catch any issues that only appear in production build) and maybe some light end-to-end tests on a deployed preview.

Documentation and Maintainability
	•	Code Documentation: Use comments to explain non-obvious code logic or complex algorithms. Document assumptions and important decisions (for example, “Using a binary search here for efficiency, assumes the list is sorted”). For public APIs (if building a library) or critical utility functions, include JSDoc comments to describe parameters, return types, and examples of usage. This helps future maintainers and integrates with editors for intellisense.
	•	Project Documentation: Maintain a strong README.md at minimum, covering how to run, build, and deploy the project. If the project is large, consider a /docs folder or a wiki for more detailed documentation (architecture overview, coding standards, deployment process, etc.). Document how state is managed, how the theming system works, any significant patterns you expect contributors to follow, etc.
	•	Changelog and Status Tracking: Use a CHANGELOG or status.md file to record notable changes, especially if others use your project as a dependency. This file should list new features, bug fixes, and breaking changes in each version. In a team, maintain a status or project board to track progress and known issues, and update it as things change. This keeps everyone aligned and aware of current state.
	•	Refactoring and Tech Debt: Periodically assess and refactor code that has grown messy or outdated. Remove TODO comments by addressing them, or create tasks in your issue tracker for them so they aren’t forgotten. Keep your dependencies and Node version up to date; upgrade Next.js and other major tools when new stable versions come out (after testing). Retire any legacy patterns in the codebase – for instance, if you moved from Redux to React Query for data, clean up the old Redux remnants to avoid confusion.
	•	Collaborative Practices: Follow good version control practices – use feature branches, make pull requests for review, and write descriptive commit messages. In commit messages and PR descriptions, explain the “why” of changes, not just the “what”. Code reviews should be welcomed; they help maintain quality and share knowledge. Be open to feedback and ready to update code based on team input. Likewise, when reviewing others’ code, be constructive and align suggestions with the guidelines in this rulebook.
	•	Continuous Learning: The web development landscape evolves quickly. Stay updated with Next.js release notes, React RFCs, and industry best practices. Regularly review documentation (e.g., Next.js docs, React docs, Tailwind changelogs) for new features that could simplify your code or improve performance. Encourage a culture of learning in the team – share interesting findings, do pair programming, or conduct the occasional lunch-and-learn on topics from this rulebook to ensure collective expertise grows over time.